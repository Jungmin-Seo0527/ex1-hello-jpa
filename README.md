# 자바 ORM 표준 JPA 프로그래밍 - 기본편

## 2. 영속성 관리 - 내부 동작 방식

### 2-1. 영속성 컨텍스트 1

![](https://i.ibb.co/s9dD6jW/bandicam-2021-07-10-15-43-27-017.jpg)

#### 영속성 컨텍스트

* JPA를 이애하는데 가장 중요한 용어
* `엔티티를 영구 저장하는 환경`이라는 뜻
* **EntityManager.persist(entity)**
* 논리적인 개념 (눈에 보이지 않는다.)
* `EntityManager`를 통해서 영속성 컨텍스트에 접근

#### 엔티티의 생명주기

* 비영속(new/transient)
    * 영속성 컨텍스트와 전혀 관계가 없는 **새로운**상태
* 영속(managed)
    * 영속성 컨텍스트에 **관리**되는 상태
* 준영속(detached)
    * 영속성 컨텍스트에 저장되었다가 **분리**된 상태
* 삭제(removed)
    * **삭제**된 상태

  ![](https://i.ibb.co/88dzGfQ/bandicam-2021-07-10-15-47-07-740.jpg)

##### 비영속

* 단순하게 객체를 생성한 상태

```java
public class Main {
    public static void main(String[] args) {
        Member member = new Member();
        member.setId("1L");
        member.setName("서정민");
    }
}
```

##### 영속

* `EntityManager`를 이용해서 영속성 컨텍스트에 엔티티를 등록

```java

public class Main {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

        EntityManager em = emf.createEntityManager();

        EntityTransaction tx = em.getTransaction();
        tx.begin();

        Member member = new Member();
        member.setId("1L");
        member.setName("서정민");
        em.persist(member);
    }
}
```

##### 준영속, 삭제

* 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태

```
em.detach(member);
```

* 객체를 삭제한 상태(삭제)

```
em.remove(member);
```

#### 영속성 컨텍스트의 이점

* 1차 캐시
* 동일성(identity)보장
* 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
* 변경 감지(Dirty Checking)
* 지연 로딩(Lazy Loading)

#### MN

스프링 부트와 JPA를 이용한 웹 애플리케이션 개발 강의를 들을 때 JPA 에 대해 모르는 부분이 나오면 구글링을 해서 찾아봤었다. 다양한 블로그를 참고 했었는데 대부분 JPA에 대한 내용의 글의 출처에 김영한님의
책이 등장했다. (역시 권위자)   
그 덕분인지 아직까지는 대부분 블로그를 통해 알고 있는 내용들이다.

강의를 듣기 전에는 영속성 컨텍스트를 단순하게 주머니 정도로 생각했다. 이를 영한님이 좀더 고급진 표현으로 설명을 해주셨다.   
애플리케이션과 데이터베이스 사이에 **계층이 하나 더 존재**한다고 생각하면 된다. 그리고 아직 강의에서 자세하게 설명하지 않은 영속성 컨텍스트의 이점에 대해 내 머릿속에만 있는 내용들을 적어본다. (강의를 보면서
이 내용들을 정리해 가면 좋을 듯 하다.)

* 1차 캐시
    * 엔티티를 조회할 때 DB에 쿼리를 날리기 전에 영속성 컨텍스트에 해당 엔티티가 있는지 조회한다. (엔티티가 영속 상태인지 확인한다는 의미)
    * 엔티티가 영속 상태이면 DB에 접근하지 않아도 엔티티를 조회할 수 있으니 리소스를 절약할 수 있다.


* 동일성(identity) 보장
    * 기본적으로 자바(그리고 다른 대부분?의 언어들...)는 주소값으로 객체를 저장한다.
    * 하지만 데이터베이스는 자바에서 사용하던 객체의 주소를 전혀 알지 못한다.(매커니즘이 다를라나???)
        * DB에도 주소값과 비슷한 인덱스라는 개념이 있지 않은가?? 구글링 해보고 추후에 정리해야겠다.
    * 따라서 엔티티를 조회하고 객체에 매핑할 때 마다 엔티티를 DB에서 가져오면 주소값이 달라진다.
        * 이 부분은 강의에서도 설명했다.
        * 엔티티가 조회될때마다 쿼리가 날라가고 엔티티를 가져오면 새로운 객체를 할당받고 매핑을 한다.
        * 당연히 새로운 객체를 조회할 때 마다 할당 받으니 주소값이 다르다.
    * 하지만 영속성 컨텍스트는 애플리케이션과 DB 사이의 계층이라고 해도 근본은 자바로 작성된 계층이기 때문에 자바에서 사용하고 있는 객체의 주소값을 알고 있다. (아마 영속성 컨텍스트에 저장을 하는 행위도
      주소값을 가지고 있는 것이라고 생각한다.)
    * 따라서 영속성 컨텍스트에 동일한 엔티티를 여러번 조회한다면 동일한 객체 주소를 반환한다.
        * 아마 매핑도 필요 없겠지?


* 변경 감지(Dirty Checking)
    * 트랜잭션이 끝나고 DB에 쿼리를 날리 전에 영속성 컨텍스트는 자신이 가지고 있는 엔티티가 변경사항이 있는 확인한다.
    * 변경사항이 있으면 자동으로 Update 쿼리를 날린다.


* 지연 로딩
    * 엔티티를 조회할 때 엔티티가 의존하는 엔티티(관계를 가지고 있는 엔티티)가 존재할 것이다.(다대일, 일대일 관계에서 일에 해당하는 객체를 의미한다.)
    * 조회를 하는 시점에서는 조회된 엔티티가 연관관계를 가지고 있는 엔티티까지는 조회되지 않는다.
    * 따라서 조회 시점에서는 프록시 객체로서 의존하는 엔티티들을 프록시 객체로 만들어 둔다.(일단 대기한다는 의미로 이해하고 있다.)
    * 이후에 연관된 엔티티들을 조회해야 하는 상황이 발생하면(단순하게 get()메소드가 발생한다면) 그때 쿼리를 날려서 필요한 엔티티를 조회한다.
    * 단 `@ManyToOne`, `@OneToOne` 애노테이션에 `fetch`를 설정해야 한다.
      `@ManyToOne(fetch = FetchType.LAZY)` (default는 `EAGER`)
    * 지연 로딩으로 `N + 1`문제를 해결할 수 있다.
        * 아마 `N + 1`은 이후 강의에 나올 것이라 예상하고 이번에는 그냥 언급만 한다.

        ```java
        public class Member {
            private final Long id;
            private final Friend friend;
        }
        
        ```
        * 코드로 설명을 추가한다(애노테이션은 생략한다.)
        * `Member`엔티티는 `Friend`엔티티와 일대일 관계라고 설정하지
        * `Member`엔티티를 조회할때 본래는 `Friend`엔티티에 대한 정보도 필요할 것이다.
        * 하지만 지연로딩에서는 `Friend`엔티티는 프록시 객체로 둔다.
        * 정확하게는 `member.getFriend()는 프록시 객체`
        * 이후에 `Friend`엔티티가 필요한 경우(`member.getFriend()`를 수행한 경우) 그때 Friend 테이블에서 필요한 엔티티를 조회한다.

### 2-2. 영속성 컨텍스트 2

#### 엔티티 조회, 1차 캐시

```java
public class Main {
    public static void main(String[] args) {

        // 엔티티를 생성한 상태 (비영속)
        Member member = new Member();
        member.setId(1L);
        member.setName("Jungmin");

        // 엔티티를 영속 - 1차 캐시에 등록
        em.persist(member);

        // DB가 아닌 캐시에서 조회
        Member findMember = em.find(Member.class, 1L);
    }
}
```

![](https://i.ibb.co/Jj8CS7K/bandicam-2021-07-10-17-57-59-015.jpg)

* 엔티티를 영속한 순간에 엔티티는 1차 캐시에 저장된다.
* 동일한 엔티티를 조회하면 해당 엔티티는 1차 캐시에 존재하므로 DB에서 조회하지 않고 1차 캐시의 엔티티를 반환해준다.
    * 단 조회한 엔티티가 1차 캐시에 없다면 DB에 접근해서 조회한다.

#### 영속 엔티티의 동일성 보장

```
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b); // true
```

* 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공

#### 엔티티 등록 - 트랜잭션을 지원하는 쓰기 지연

* 트랜잭션을 커밋을 해야 영속성 컨텍스의 `쓰기 지연 SQL 저장소`에서 DB에 쿼리를 보낸다.

#### 변경 감지

![](https://i.ibb.co/j60VjL6/bandicam-2021-07-10-18-05-12-676.jpg)

* 엔티티를 변경하면 (`member.setName("다른 이름")`) 영속성 컨텍스트는 트랜잭션이 끝난 이후 변경 사항을 확인한다.
* 변경 사항이 존재한다면 쓰기 지연 SQL 저장소에서 `Update`쿼리문을 생성한다.
* 일괄적으로 DB에 쿼리를 보내서 변경사항을 적용한다.
* 개발자 입장에서 `em.update(member)`와 같은 갱신에 대한 코드를 작성할 필요가 없다.

#### 엔티티 삭제

`em.remove(member)`

#### MN

이전 강의에서 내가 알고 있는 영속성 컨텍스트의 장점, 특징에 대한 내용을 거의 다 일치한다.

현 시점에서 아직 강의에 나오지 않는 내용은 지연 로딩이다.

1차 캐시, 동일성 보장, 쓰기 지연, 변경감지 까지는 강의 내용과 내가 알고 있는 내용이 일치함을 확인했다.

한가지 다른점이 존재한다.

나는 1차 캐시 자체에서 변경감지가 일어나면 쿼리문을 생성하는 것인줄 알았으나, 쓰기 지연 SQL 저장소라는 쿼리문 생성 역할을 담당하는 객체? 가 존재서 일괄적으로 쿼리문을 생성했다.         
1차 캐시에는 변경감지, 쿼리문은 쓰기 지연 SQL 저장소

### 2-3. 플러시

#### 플러시

* 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
* 발생
    * 변경 감지
    * 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
    * 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)
* 방법
    * `em.flush()`: 직접 호출
    * `트랜잭션 커밋`: 플러시 자동 호출
    * `JPQL 쿼리 실행`: 플러시 자동 호출
        * 만약 `Member`엔티티를 `em.persist(member)`를 하고
        * `Member`테이블의 모든 엔티티를 조회하는 JPQL 쿼리를 실행하면
        * JPQL은 바로 쿼리문을 DB로 보내서 데이터를 조회하는데 영속성 컨텍스트에 존재하는 `Member`엔티티가 flush가 되지 않으면 DB에서 조회는 불가능하다.
        * 따라서 JPQL을 실행하기 전에 flush로 DB를 최신화를 시킨 후에 JPQL를 실행한다.

* 플러시 모드 옵션 - 아마 쓸일 없을 것이다.
    * `em.setFlushMode(FlushModeType.COMMIT)`
        * `FlushModeType.AUTO`: 커밋이나 쿼리를 실행할 때 플러시 (기본값)
        * `FlushModeType.COMMIT`: 커밋할 때만 플러시

* 특징
    * 영속성 커텍스트를 비우지 않는다.
    * 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
    * 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 됨

#### MN

JPA와 스프링 부트를 이용한 웹 애플리케이션 개발하기 강의가 왜 탄생했는지 알것 같다. JPA 강의가 전반적으로 이론을 중심으로 하는 듯 하다.

# Note